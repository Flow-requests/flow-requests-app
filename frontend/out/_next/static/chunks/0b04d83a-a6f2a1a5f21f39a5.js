"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[421],{51980:(t,e,a)=>{a.d(e,{Kj:()=>E});var i=a(32197),s=a(22383),r=a(11164),n=a(7356),o=a(38805),l=a(69988),h=a(94718),d=a(20553),u=a(55165),p=a(15764),c=a(67085),m=a(25822),f=a(94388);function g(t,e,a){if(a)return t;let i=(0,l.Ec)(),s=e??(0,l.I6)(),r=t.extra??{},n=r.metadata;return t.extra={...r,runtime:{...i,...r?.runtime},metadata:{...s,...s.revision_id||"revision_id"in t&&t.revision_id?{revision_id:("revision_id"in t?t.revision_id:void 0)??s.revision_id}:{},...n}},t}let w=t=>{let e=t?.toString()??(0,l.Jz)("TRACING_SAMPLING_RATE");if(void 0===e)return;let a=parseFloat(e);if(a<0||a>1)throw Error(`LANGSMITH_TRACING_SAMPLING_RATE must be between 0 and 1 if set. Got: ${a}`);return a},_=t=>{let e=t.replace("http://","").replace("https://","").split("/")[0].split(":")[0];return"localhost"===e||"127.0.0.1"===e||"::1"===e};async function y(t){let e=[];for await(let a of t)e.push(a);return e}function b(t){if(void 0!==t)return t.trim().replace(/^"(.*)"$/,"$1").replace(/^'(.*)'$/,"$1")}let v=async t=>{if(t?.status===429){let e=1e3*parseInt(t.headers.get("retry-after")??"10",10);if(e>0)return await new Promise(t=>setTimeout(t,e)),!0}return!1};function S(t){return"number"==typeof t?Number(t.toFixed(4)):t}let $="https://api.smith.langchain.com";class O{constructor(t){Object.defineProperty(this,"items",{enumerable:!0,configurable:!0,writable:!0,value:[]}),Object.defineProperty(this,"sizeBytes",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"maxSizeBytes",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSizeBytes=t??0x40000000}peek(){return this.items[0]}push(t){let e,a=new Promise(t=>{e=t}),i=(0,f.l)(t.item,`Serializing run with id: ${t.item.id}`).length;return this.sizeBytes+i>this.maxSizeBytes&&this.items.length>0?(console.warn(`AutoBatchQueue size limit (${this.maxSizeBytes} bytes) exceeded. Dropping run with id: ${t.item.id}. Current queue size: ${this.sizeBytes} bytes, attempted addition: ${i} bytes.`),e()):(this.items.push({action:t.action,payload:t.item,otelContext:t.otelContext,apiKey:t.apiKey,apiUrl:t.apiUrl,itemPromiseResolve:e,itemPromise:a,size:i}),this.sizeBytes+=i),a}pop({upToSizeBytes:t,upToSize:e}){if(t<1)throw Error("Number of bytes to pop off may not be less than 1.");let a=[],i=0;for(;i+(this.peek()?.size??0)<t&&this.items.length>0&&a.length<e;){let t=this.items.shift();t&&(a.push(t),i+=t.size,this.sizeBytes-=t.size)}if(0===a.length&&this.items.length>0){let t=this.items.shift();a.push(t),i+=t.size,this.sizeBytes-=t.size}return[a.map(t=>({action:t.action,item:t.payload,otelContext:t.otelContext,apiKey:t.apiKey,apiUrl:t.apiUrl,size:t.size})),()=>a.forEach(t=>t.itemPromiseResolve())]}}class E{get _fetch(){return this.fetchImplementation||(0,m.Yx)(this.debug)}constructor(t={}){Object.defineProperty(this,"apiKey",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"apiUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"webUrl",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"workspaceId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"caller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"batchIngestCaller",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"timeout_ms",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_tenantId",{enumerable:!0,configurable:!0,writable:!0,value:null}),Object.defineProperty(this,"hideInputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"hideOutputs",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"omitTracedRuntimeInfo",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"tracingSampleRate",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"filteredPostUuids",{enumerable:!0,configurable:!0,writable:!0,value:new Set}),Object.defineProperty(this,"autoBatchTracing",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"autoBatchQueue",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"autoBatchTimeout",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"autoBatchAggregationDelayMs",{enumerable:!0,configurable:!0,writable:!0,value:250}),Object.defineProperty(this,"batchSizeBytesLimit",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"batchSizeLimit",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"fetchOptions",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"settings",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"blockOnRootRunFinalization",{enumerable:!0,configurable:!0,writable:!0,value:"false"===(0,l.Az)("LANGSMITH_TRACING_BACKGROUND")}),Object.defineProperty(this,"traceBatchConcurrency",{enumerable:!0,configurable:!0,writable:!0,value:5}),Object.defineProperty(this,"_serverInfo",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_getServerInfoPromise",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"manualFlushMode",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"langSmithToOTELTranslator",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"fetchImplementation",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"cachedLSEnvVarsForMetadata",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"multipartStreamingDisabled",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"_multipartDisabled",{enumerable:!0,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"debug",{enumerable:!0,configurable:!0,writable:!0,value:"true"===(0,l.Az)("LANGSMITH_DEBUG")});let e=E.getDefaultClientConfig();if(this.tracingSampleRate=w(t.tracingSamplingRate),this.apiUrl=b(t.apiUrl??e.apiUrl)??"",this.apiUrl.endsWith("/")&&(this.apiUrl=this.apiUrl.slice(0,-1)),this.apiKey=b(t.apiKey??e.apiKey),this.webUrl=b(t.webUrl??e.webUrl),this.webUrl?.endsWith("/")&&(this.webUrl=this.webUrl.slice(0,-1)),this.workspaceId=b(t.workspaceId??(0,l.Jz)("WORKSPACE_ID")),this.timeout_ms=t.timeout_ms??9e4,this.caller=new n.g({...t.callerOptions??{},maxRetries:4,debug:t.debug??this.debug}),this.traceBatchConcurrency=t.traceBatchConcurrency??this.traceBatchConcurrency,this.traceBatchConcurrency<1)throw Error("Trace batch concurrency must be positive.");this.debug=t.debug??this.debug,this.fetchImplementation=t.fetchImplementation;let a=t.maxIngestMemoryBytes??0x40000000;this.batchIngestCaller=new n.g({maxRetries:4,maxConcurrency:this.traceBatchConcurrency,maxQueueSizeBytes:a,...t.callerOptions??{},onFailedResponseHook:v,debug:t.debug??this.debug}),this.hideInputs=t.hideInputs??t.anonymizer??e.hideInputs,this.hideOutputs=t.hideOutputs??t.anonymizer??e.hideOutputs,this.omitTracedRuntimeInfo=t.omitTracedRuntimeInfo??!1,this.autoBatchTracing=t.autoBatchTracing??this.autoBatchTracing,this.autoBatchQueue=new O(a),this.blockOnRootRunFinalization=t.blockOnRootRunFinalization??this.blockOnRootRunFinalization,this.batchSizeBytesLimit=t.batchSizeBytesLimit,this.batchSizeLimit=t.batchSizeLimit,this.fetchOptions=t.fetchOptions||{},this.manualFlushMode=t.manualFlushMode??this.manualFlushMode,(0,l.QK)()&&(this.langSmithToOTELTranslator=new s.T),this.cachedLSEnvVarsForMetadata=(0,l.I6)()}static getDefaultClientConfig(){let t=(0,l.Jz)("API_KEY"),e=(0,l.Jz)("ENDPOINT")??$;return{apiUrl:e,apiKey:t,webUrl:void 0,hideInputs:"true"===(0,l.Jz)("HIDE_INPUTS"),hideOutputs:"true"===(0,l.Jz)("HIDE_OUTPUTS")}}getHostUrl(){if(this.webUrl)return this.webUrl;if(_(this.apiUrl))return this.webUrl="http://localhost:3000",this.webUrl;if(this.apiUrl.endsWith("/api/v1"))return this.webUrl=this.apiUrl.replace("/api/v1",""),this.webUrl;if(this.apiUrl.includes("/api")&&!this.apiUrl.split(".",1)[0].endsWith("api"))return this.webUrl=this.apiUrl.replace("/api",""),this.webUrl;if(this.apiUrl.split(".",1)[0].includes("dev"))return this.webUrl="https://dev.smith.langchain.com",this.webUrl;else if(this.apiUrl.split(".",1)[0].includes("eu"))return this.webUrl="https://eu.smith.langchain.com",this.webUrl;else if(this.apiUrl.split(".",1)[0].includes("beta"))return this.webUrl="https://beta.smith.langchain.com",this.webUrl;else return this.webUrl="https://smith.langchain.com",this.webUrl}get headers(){let t={"User-Agent":`langsmith-js/${h.Ls}`};return this.apiKey&&(t["x-api-key"]=`${this.apiKey}`),this.workspaceId&&(t["x-tenant-id"]=this.workspaceId),t}_getPlatformEndpointPath(t){return"/v1"!==this.apiUrl.slice(-3)&&"/v1/"!==this.apiUrl.slice(-4)?`/v1/platform/${t}`:`/platform/${t}`}async processInputs(t){return!1===this.hideInputs?t:!0===this.hideInputs?{}:"function"==typeof this.hideInputs?this.hideInputs(t):t}async processOutputs(t){return!1===this.hideOutputs?t:!0===this.hideOutputs?{}:"function"==typeof this.hideOutputs?this.hideOutputs(t):t}async prepareRunCreateOrUpdateInputs(t){let e={...t};return void 0!==e.inputs&&(e.inputs=await this.processInputs(e.inputs)),void 0!==e.outputs&&(e.outputs=await this.processOutputs(e.outputs)),e}async _getResponse(t,e){let a=e?.toString()??"",i=`${this.apiUrl}${t}?${a}`;return await this.caller.call(async()=>{let e=await this._fetch(i,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,`fetch ${t}`),e})}async _get(t,e){return(await this._getResponse(t,e)).json()}async *_getPaginated(t,e=new URLSearchParams,a){let i=Number(e.get("offset"))||0,s=Number(e.get("limit"))||100;for(;;){e.set("offset",String(i)),e.set("limit",String(s));let r=`${this.apiUrl}${t}?${e}`,n=await this.caller.call(async()=>{let e=await this._fetch(r,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,`fetch ${t}`),e}),o=a?a(await n.json()):await n.json();if(0===o.length||(yield o,o.length<s))break;i+=o.length}}async *_getCursorPaginatedList(t,e=null,a="POST",i="runs"){let s=e?{...e}:{};for(;;){let e=JSON.stringify(s),r=await this.caller.call(async()=>{let i=await this._fetch(`${this.apiUrl}${t}`,{method:a,headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:e});return await (0,c.gJ)(i,`fetch ${t}`),i}),n=await r.json();if(!n||!n[i])break;yield n[i];let o=n.cursors;if(!o||!o.next)break;s.cursor=o.next}}_shouldSample(){return void 0===this.tracingSampleRate||Math.random()<this.tracingSampleRate}_filterForSampling(t,e=!1){if(void 0===this.tracingSampleRate)return t;if(e){let e=[];for(let a of t)this.filteredPostUuids.has(a.trace_id)?a.id===a.trace_id&&this.filteredPostUuids.delete(a.trace_id):e.push(a);return e}{let e=[];for(let a of t){let t=a.trace_id??a.id;this.filteredPostUuids.has(t)||(a.id===t?this._shouldSample()?e.push(a):this.filteredPostUuids.add(t):e.push(a))}return e}}async _getBatchSizeLimitBytes(){let t=await this._ensureServerInfo();return this.batchSizeBytesLimit??t?.batch_ingest_config?.size_limit_bytes??0x1800000}async _getBatchSizeLimit(){let t=await this._ensureServerInfo();return this.batchSizeLimit??t?.batch_ingest_config?.size_limit??100}async _getDatasetExamplesMultiPartSupport(){let t=await this._ensureServerInfo();return t.instance_flags?.dataset_examples_multipart_enabled??!1}drainAutoBatchQueue({batchSizeLimitBytes:t,batchSizeLimit:e}){let a=[];for(;this.autoBatchQueue.items.length>0;){let[i,s]=this.autoBatchQueue.pop({upToSizeBytes:t,upToSize:e});if(!i.length){s();break}let r=i.reduce((t,e)=>{let a=e.apiUrl??this.apiUrl,i=e.apiKey??this.apiKey,s=e.apiKey===this.apiKey&&e.apiUrl===this.apiUrl?"default":`${a}|${i}`;return t[s]||(t[s]=[]),t[s].push(e),t},{}),n=[];for(let[t,e]of Object.entries(r)){let a=this._processBatch(e,{apiUrl:"default"===t?void 0:t.split("|")[0],apiKey:"default"===t?void 0:t.split("|")[1]});n.push(a)}let o=Promise.all(n).finally(s);a.push(o)}return Promise.all(a)}async _processBatch(t,e){if(!t.length)return;let a=t.reduce((t,e)=>t+(e.size??0),0);try{if(void 0!==this.langSmithToOTELTranslator)this._sendBatchToOTELTranslator(t);else{let i={runCreates:t.filter(t=>"create"===t.action).map(t=>t.item),runUpdates:t.filter(t=>"update"===t.action).map(t=>t.item)},s=await this._ensureServerInfo();if(!this._multipartDisabled&&(s?.batch_ingest_config?.use_multipart_endpoint??!0)){let t=s?.instance_flags?.gzip_body_enabled;try{await this.multipartIngestRuns(i,{...e,useGzip:t,sizeBytes:a})}catch(t){if((0,c.xJ)(t))this._multipartDisabled=!0,await this.batchIngestRuns(i,{...e,sizeBytes:a});else throw t}}else await this.batchIngestRuns(i,{...e,sizeBytes:a})}}catch(t){console.error("Error exporting batch:",t)}}_sendBatchToOTELTranslator(t){if(void 0!==this.langSmithToOTELTranslator){let e=new Map,a=[];for(let i of t)i.item.id&&i.otelContext&&(e.set(i.item.id,i.otelContext),"create"===i.action?a.push({operation:"post",id:i.item.id,trace_id:i.item.trace_id??i.item.id,run:i.item}):a.push({operation:"patch",id:i.item.id,trace_id:i.item.trace_id??i.item.id,run:i.item}));this.langSmithToOTELTranslator.exportBatch(a,e)}}async processRunOperation(t){clearTimeout(this.autoBatchTimeout),this.autoBatchTimeout=void 0,t.item=g(t.item,this.cachedLSEnvVarsForMetadata,this.omitTracedRuntimeInfo);let e=this.autoBatchQueue.push(t);if(this.manualFlushMode)return e;let a=await this._getBatchSizeLimitBytes(),i=await this._getBatchSizeLimit();return(this.autoBatchQueue.sizeBytes>a||this.autoBatchQueue.items.length>i)&&this.drainAutoBatchQueue({batchSizeLimitBytes:a,batchSizeLimit:i}),this.autoBatchQueue.items.length>0&&(this.autoBatchTimeout=setTimeout(()=>{this.autoBatchTimeout=void 0,this.drainAutoBatchQueue({batchSizeLimitBytes:a,batchSizeLimit:i})},this.autoBatchAggregationDelayMs)),e}async _getServerInfo(){let t=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/info`,{method:"GET",headers:{Accept:"application/json"},signal:AbortSignal.timeout(1e4),...this.fetchOptions});return await (0,c.gJ)(t,"get server info"),t}),e=await t.json();return this.debug&&console.log("\n=== LangSmith Server Configuration ===\n"+JSON.stringify(e,null,2)+"\n"),e}async _ensureServerInfo(){return void 0===this._getServerInfoPromise&&(this._getServerInfoPromise=(async()=>{if(void 0===this._serverInfo)try{this._serverInfo=await this._getServerInfo()}catch(t){console.warn(`[LANGSMITH]: Failed to fetch info on supported operations. Falling back to batch operations and default limits. Info: ${t.status??"Unspecified status code"} ${t.message}`)}return this._serverInfo??{}})()),this._getServerInfoPromise.then(t=>(void 0===this._serverInfo&&(this._getServerInfoPromise=void 0),t))}async _getSettings(){return this.settings||(this.settings=this._get("/settings")),await this.settings}async flush(){let t=await this._getBatchSizeLimitBytes(),e=await this._getBatchSizeLimit();await this.drainAutoBatchQueue({batchSizeLimitBytes:t,batchSizeLimit:e})}_cloneCurrentOTELContext(){let t=(0,r.sW)(),e=(0,r.wb)();if(void 0!==this.langSmithToOTELTranslator){let a=t.getActiveSpan();if(a)return t.setSpan(e.active(),a)}}async createRun(t,e){if(!this._filterForSampling([t]).length)return;let a={...this.headers,"Content-Type":"application/json"},i=t.project_name;delete t.project_name;let s=await this.prepareRunCreateOrUpdateInputs({session_name:i,...t,start_time:t.start_time??Date.now()});if(this.autoBatchTracing&&void 0!==s.trace_id&&void 0!==s.dotted_order){let t=this._cloneCurrentOTELContext();this.processRunOperation({action:"create",item:s,otelContext:t,apiKey:e?.apiKey,apiUrl:e?.apiUrl}).catch(console.error);return}let r=g(s,this.cachedLSEnvVarsForMetadata,this.omitTracedRuntimeInfo);e?.apiKey!==void 0&&(a["x-api-key"]=e.apiKey),e?.workspaceId!==void 0&&(a["x-tenant-id"]=e.workspaceId);let n=(0,f.l)(r,`Creating run with id: ${r.id}`);await this.caller.call(async()=>{let t=await this._fetch(`${e?.apiUrl??this.apiUrl}/runs`,{method:"POST",headers:a,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:n});return await (0,c.gJ)(t,"create run",!0),t})}async batchIngestRuns({runCreates:t,runUpdates:e},a){if(void 0===t&&void 0===e)return;let i=await Promise.all(t?.map(t=>this.prepareRunCreateOrUpdateInputs(t))??[]),s=await Promise.all(e?.map(t=>this.prepareRunCreateOrUpdateInputs(t))??[]);if(i.length>0&&s.length>0){let t=i.reduce((t,e)=>(e.id&&(t[e.id]=e),t),{}),e=[];for(let a of s)void 0!==a.id&&t[a.id]?t[a.id]={...t[a.id],...a}:e.push(a);i=Object.values(t),s=e}let r={post:i,patch:s};if(!r.post.length&&!r.patch.length)return;let n={post:[],patch:[]};for(let t of["post","patch"]){let e=r[t].reverse(),a=e.pop();for(;void 0!==a;)n[t].push(a),a=e.pop()}if(n.post.length>0||n.patch.length>0){let t=n.post.map(t=>t.id).concat(n.patch.map(t=>t.id)).join(",");await this._postBatchIngestRuns((0,f.l)(n,`Ingesting runs with ids: ${t}`),a)}}async _postBatchIngestRuns(t,e){let a={...this.headers,"Content-Type":"application/json",Accept:"application/json"};e?.apiKey!==void 0&&(a["x-api-key"]=e.apiKey),await this.batchIngestCaller.callWithOptions({sizeBytes:e?.sizeBytes},async()=>{let i=await this._fetch(`${e?.apiUrl??this.apiUrl}/runs/batch`,{method:"POST",headers:a,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:t});return await (0,c.gJ)(i,"batch create run",!0),i})}async multipartIngestRuns({runCreates:t,runUpdates:e},a){if(void 0===t&&void 0===e)return;let i={},s=[];for(let e of t??[]){let t=await this.prepareRunCreateOrUpdateInputs(e);void 0!==t.id&&void 0!==t.attachments&&(i[t.id]=t.attachments),delete t.attachments,s.push(t)}let r=[];for(let t of e??[])r.push(await this.prepareRunCreateOrUpdateInputs(t));if(void 0!==s.find(t=>void 0===t.trace_id||void 0===t.dotted_order))throw Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when creating a run');if(void 0!==r.find(t=>void 0===t.trace_id||void 0===t.dotted_order))throw Error('Multipart ingest requires "trace_id" and "dotted_order" to be set when updating a run');if(s.length>0&&r.length>0){let t=s.reduce((t,e)=>(e.id&&(t[e.id]=e),t),{}),e=[];for(let a of r)void 0!==a.id&&t[a.id]?t[a.id]={...t[a.id],...a}:e.push(a);s=Object.values(t),r=e}if(0===s.length&&0===r.length)return;let n=[],o=[];for(let[t,e]of[["post",s],["patch",r]])for(let a of e){let{inputs:e,outputs:s,events:r,extra:l,error:h,serialized:d,attachments:u,...p}=a,c={inputs:e,outputs:s,events:r,extra:l,error:h,serialized:d},m=(0,f.l)(p,`Serializing for multipart ingestion of run with id: ${p.id}`);for(let[e,a]of(o.push({name:`${t}.${p.id}`,payload:new Blob([m],{type:`application/json; length=${m.length}`})}),Object.entries(c))){if(void 0===a)continue;let i=(0,f.l)(a,`Serializing ${e} for multipart ingestion of run with id: ${p.id}`);o.push({name:`${t}.${p.id}.${e}`,payload:new Blob([i],{type:`application/json; length=${i.length}`})})}if(void 0!==p.id){let t=i[p.id];if(t)for(let[e,a]of(delete i[p.id],Object.entries(t))){let t,i;if(Array.isArray(a)?[t,i]=a:(t=a.mimeType,i=a.data),e.includes(".")){console.warn(`Skipping attachment '${e}' for run ${p.id}: Invalid attachment name. Attachment names must not contain periods ('.'). Please rename the attachment and try again.`);continue}o.push({name:`attachment.${p.id}.${e}`,payload:new Blob([i],{type:`${t}; length=${i.byteLength}`})})}}n.push(`trace=${p.trace_id},id=${p.id}`)}await this._sendMultipartRequest(o,n.join("; "),a)}async _createNodeFetchBody(t,e){let a=[];for(let i of t)a.push(new Blob([`--${e}\r
`])),a.push(new Blob([`Content-Disposition: form-data; name="${i.name}"\r
`,`Content-Type: ${i.payload.type}\r
\r
`])),a.push(i.payload),a.push(new Blob(["\r\n"]));a.push(new Blob([`--${e}--\r
`]));let i=new Blob(a);return await i.arrayBuffer()}async _createMultipartStream(t,e){let a=new TextEncoder;return new ReadableStream({async start(i){let s=async t=>{"string"==typeof t?i.enqueue(a.encode(t)):i.enqueue(t)};for(let a of t){await s(`--${e}\r
`),await s(`Content-Disposition: form-data; name="${a.name}"\r
`),await s(`Content-Type: ${a.payload.type}\r
\r
`);let t=a.payload.stream().getReader();try{let e;for(;!(e=await t.read()).done;)i.enqueue(e.value)}finally{t.releaseLock()}await s("\r\n")}await s(`--${e}--\r
`),i.close()}})}async _sendMultipartRequest(t,e,a){let i="----LangSmithFormBoundary"+Math.random().toString(36).slice(2),s=(0,m.rO)(),r=()=>this._createNodeFetchBody(t,i),n=async t=>this.batchIngestCaller.callWithOptions({sizeBytes:a?.sizeBytes},async()=>{let e=await t(),s={...this.headers,"Content-Type":`multipart/form-data; boundary=${i}`};a?.apiKey!==void 0&&(s["x-api-key"]=a.apiKey);let r=e;a?.useGzip&&"object"==typeof e&&"pipeThrough"in e&&(r=e.pipeThrough(new CompressionStream("gzip")),s["Content-Encoding"]="gzip");let n=await this._fetch(`${a?.apiUrl??this.apiUrl}/runs/multipart`,{method:"POST",headers:s,body:r,duplex:"half",signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(n,"Failed to send multipart request",!0),n});try{let o,h=!1;s||this.multipartStreamingDisabled||"bun"===(0,l._$)()?o=await n(r):(h=!0,o=await n(()=>this._createMultipartStream(t,i))),(!this.multipartStreamingDisabled||h)&&422===o.status&&(a?.apiUrl??this.apiUrl)!==$&&(console.warn(`Streaming multipart upload to ${a?.apiUrl??this.apiUrl}/runs/multipart failed. This usually means the host does not support chunked uploads. Retrying with a buffered upload for operation "${e}".`),this.multipartStreamingDisabled=!0,o=await n(r))}catch(t){if((0,c.xJ)(t))throw t;console.warn(`${t.message.trim()}

Context: ${e}`)}}async updateRun(t,e,a){(0,d.AD)(t),e.inputs&&(e.inputs=await this.processInputs(e.inputs)),e.outputs&&(e.outputs=await this.processOutputs(e.outputs));let i={...e,id:t};if(!this._filterForSampling([i],!0).length)return;if(this.autoBatchTracing&&void 0!==i.trace_id&&void 0!==i.dotted_order){let t=this._cloneCurrentOTELContext();return void 0!==e.end_time&&void 0===i.parent_run_id&&this.blockOnRootRunFinalization&&!this.manualFlushMode?void await this.processRunOperation({action:"update",item:i,otelContext:t,apiKey:a?.apiKey,apiUrl:a?.apiUrl}).catch(console.error):void this.processRunOperation({action:"update",item:i,otelContext:t,apiKey:a?.apiKey,apiUrl:a?.apiUrl}).catch(console.error)}let s={...this.headers,"Content-Type":"application/json"};a?.apiKey!==void 0&&(s["x-api-key"]=a.apiKey),a?.workspaceId!==void 0&&(s["x-tenant-id"]=a.workspaceId);let r=(0,f.l)(e,`Serializing payload to update run with id: ${t}`);await this.caller.call(async()=>{let e=await this._fetch(`${a?.apiUrl??this.apiUrl}/runs/${t}`,{method:"PATCH",headers:s,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:r});return await (0,c.gJ)(e,"update run",!0),e})}async readRun(t,{loadChildRuns:e}={loadChildRuns:!1}){(0,d.AD)(t);let a=await this._get(`/runs/${t}`);return e&&(a=await this._loadChildRuns(a)),a}async getRunUrl({runId:t,run:e,projectOpts:a}){if(void 0!==e){let t;t=e.session_id?e.session_id:a?.projectName?(await this.readProject({projectName:a?.projectName})).id:a?.projectId?a?.projectId:(await this.readProject({projectName:(0,l.Jz)("PROJECT")||"default"})).id;let i=await this._getTenantId();return`${this.getHostUrl()}/o/${i}/projects/p/${t}/r/${e.id}?poll=true`}if(void 0!==t){let e=await this.readRun(t);if(!e.app_path)throw Error(`Run ${t} has no app_path`);let a=this.getHostUrl();return`${a}${e.app_path}`}throw Error("Must provide either runId or run")}async _loadChildRuns(t){let e=await y(this.listRuns({isRoot:!1,projectId:t.session_id,traceId:t.trace_id})),a={},i={};for(let s of(e.sort((t,e)=>(t?.dotted_order??"").localeCompare(e?.dotted_order??"")),e)){if(null===s.parent_run_id||void 0===s.parent_run_id)throw Error(`Child run ${s.id} has no parent`);s.dotted_order?.startsWith(t.dotted_order??"")&&s.id!==t.id&&(s.parent_run_id in a||(a[s.parent_run_id]=[]),a[s.parent_run_id].push(s),i[s.id]=s)}for(let e in t.child_runs=a[t.id]||[],a)e!==t.id&&(i[e].child_runs=a[e]);return t}async *listRuns(t){let{projectId:e,projectName:a,parentRunId:i,traceId:s,referenceExampleId:r,startTime:n,executionOrder:o,isRoot:l,runType:h,error:d,id:p,query:c,filter:m,traceFilter:f,treeFilter:g,limit:w,select:_,order:y}=t,b=[];if(e&&(b=Array.isArray(e)?e:[e]),a){let t=Array.isArray(a)?a:[a],e=await Promise.all(t.map(t=>this.readProject({projectName:t}).then(t=>t.id)));b.push(...e)}let v={session:b.length?b:null,run_type:h,reference_example:r,query:c,filter:m,trace_filter:f,tree_filter:g,execution_order:o,parent_run:i,start_time:n?n.toISOString():null,error:d,id:p,limit:w,trace:s,select:_||["app_path","completion_cost","completion_tokens","dotted_order","end_time","error","events","extra","feedback_stats","first_token_time","id","inputs","name","outputs","parent_run_id","parent_run_ids","prompt_cost","prompt_tokens","reference_example_id","run_type","session_id","start_time","status","tags","total_cost","total_tokens","trace_id"],is_root:l,order:y};v.select.includes("child_run_ids")&&(0,u.m)("Deprecated: 'child_run_ids' in the listRuns select parameter is deprecated and will be removed in a future version.");let S=0;for await(let t of this._getCursorPaginatedList("/runs/query",v))if(w){if(S>=w)break;if(t.length+S>w){let e=t.slice(0,w-S);yield*e;break}S+=t.length,yield*t}else yield*t}async *listGroupRuns(t){let{projectId:e,projectName:a,groupBy:i,filter:s,startTime:r,endTime:n,limit:o,offset:l}=t,h={session_id:e||(await this.readProject({projectName:a})).id,group_by:i,filter:s,start_time:r?r.toISOString():null,end_time:n?n.toISOString():null,limit:Number(o)||100},d=Number(l)||0,u="/runs/group",p=`${this.apiUrl}${u}`;for(;;){let t=JSON.stringify(Object.fromEntries(Object.entries({...h,offset:d}).filter(([t,e])=>void 0!==e))),e=await this.caller.call(async()=>{let e=await this._fetch(p,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:t});return await (0,c.gJ)(e,`Failed to fetch ${u}`),e}),{groups:a,total:i}=await e.json();if(0===a.length)break;for(let t of a)yield t;if((d+=a.length)>=i)break}}async getRunStats({id:t,trace:e,parentRun:a,runType:i,projectNames:s,projectIds:r,referenceExampleIds:n,startTime:o,endTime:l,error:h,query:d,filter:u,traceFilter:p,treeFilter:m,isRoot:f,dataSourceType:g}){let w=r||[];s&&(w=[...r||[],...await Promise.all(s.map(t=>this.readProject({projectName:t}).then(t=>t.id)))]);let _=JSON.stringify(Object.fromEntries(Object.entries({id:t,trace:e,parent_run:a,run_type:i,session:w,reference_example:n,start_time:o,end_time:l,error:h,query:d,filter:u,trace_filter:p,tree_filter:m,is_root:f,data_source_type:g}).filter(([t,e])=>void 0!==e))),y=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/runs/stats`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:_});return await (0,c.gJ)(t,"get run stats"),t});return await y.json()}async shareRun(t,{shareId:e}={}){let a={run_id:t,share_token:e||i.A()};(0,d.AD)(t);let s=JSON.stringify(a),r=await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/runs/${t}/share`,{method:"PUT",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:s});return await (0,c.gJ)(e,"share run"),e}),n=await r.json();if(null===n||!("share_token"in n))throw Error("Invalid response from server");return`${this.getHostUrl()}/public/${n.share_token}/r`}async unshareRun(t){(0,d.AD)(t),await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/runs/${t}/share`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"unshare run",!0),e})}async readRunSharedLink(t){(0,d.AD)(t);let e=await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/runs/${t}/share`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"read run shared link"),e}),a=await e.json();if(null!==a&&"share_token"in a)return`${this.getHostUrl()}/public/${a.share_token}/r`}async listSharedRuns(t,{runIds:e}={}){let a=new URLSearchParams({share_token:t});if(void 0!==e)for(let t of e)a.append("id",t);(0,d.AD)(t);let i=await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/public/${t}/runs${a}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"list shared runs"),e});return await i.json()}async readDatasetSharedSchema(t,e){if(!t&&!e)throw Error("Either datasetId or datasetName must be given");t||(t=(await this.readDataset({datasetName:e})).id),(0,d.AD)(t);let a=await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/datasets/${t}/share`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"read dataset shared schema"),e}),i=await a.json();return i.url=`${this.getHostUrl()}/public/${i.share_token}/d`,i}async shareDataset(t,e){if(!t&&!e)throw Error("Either datasetId or datasetName must be given");t||(t=(await this.readDataset({datasetName:e})).id);let a={dataset_id:t};(0,d.AD)(t);let i=JSON.stringify(a),s=await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/datasets/${t}/share`,{method:"PUT",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:i});return await (0,c.gJ)(e,"share dataset"),e}),r=await s.json();return r.url=`${this.getHostUrl()}/public/${r.share_token}/d`,r}async unshareDataset(t){(0,d.AD)(t),await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/datasets/${t}/share`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"unshare dataset",!0),e})}async readSharedDataset(t){(0,d.AD)(t);let e=await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/public/${t}/datasets`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"read shared dataset"),e});return await e.json()}async listSharedExamples(t,e){let a={};e?.exampleIds&&(a.id=e.exampleIds);let i=new URLSearchParams;Object.entries(a).forEach(([t,e])=>{Array.isArray(e)?e.forEach(e=>i.append(t,e)):i.append(t,e)});let s=await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/public/${t}/examples?${i.toString()}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"list shared examples"),e}),r=await s.json();if(!s.ok){if("detail"in r)throw Error(`Failed to list shared examples.
Status: ${s.status}
Message: ${Array.isArray(r.detail)?r.detail.join("\n"):"Unspecified error"}`);throw Error(`Failed to list shared examples: ${s.status} ${s.statusText}`)}return r.map(t=>({...t,_hostUrl:this.getHostUrl()}))}async createProject({projectName:t,description:e=null,metadata:a=null,upsert:i=!1,projectExtra:s=null,referenceDatasetId:r=null}){let n=`${this.apiUrl}/sessions${i?"?upsert=true":""}`,o=s||{};a&&(o.metadata=a);let l={name:t,extra:o,description:e};null!==r&&(l.reference_dataset_id=r);let h=JSON.stringify(l),d=await this.caller.call(async()=>{let t=await this._fetch(n,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:h});return await (0,c.gJ)(t,"create project"),t});return await d.json()}async updateProject(t,{name:e=null,description:a=null,metadata:i=null,projectExtra:s=null,endTime:r=null}){let n=`${this.apiUrl}/sessions/${t}`,o=s;i&&(o={...o||{},metadata:i});let l=JSON.stringify({name:e,extra:o,description:a,end_time:r?new Date(r).toISOString():null}),h=await this.caller.call(async()=>{let t=await this._fetch(n,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:l});return await (0,c.gJ)(t,"update project"),t});return await h.json()}async hasProject({projectId:t,projectName:e}){let a="/sessions",i=new URLSearchParams;if(void 0!==t&&void 0!==e)throw Error("Must provide either projectName or projectId, not both");if(void 0!==t)(0,d.AD)(t),a+=`/${t}`;else if(void 0!==e)i.append("name",e);else throw Error("Must provide projectName or projectId");let s=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}${a}?${i}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(t,"has project"),t});try{let t=await s.json();if(!s.ok)return!1;if(Array.isArray(t))return t.length>0;return!0}catch(t){return!1}}async readProject({projectId:t,projectName:e,includeStats:a}){let i,s="/sessions",r=new URLSearchParams;if(void 0!==t&&void 0!==e)throw Error("Must provide either projectName or projectId, not both");if(void 0!==t)(0,d.AD)(t),s+=`/${t}`;else if(void 0!==e)r.append("name",e);else throw Error("Must provide projectName or projectId");void 0!==a&&r.append("include_stats",a.toString());let n=await this._get(s,r);if(Array.isArray(n)){if(0===n.length)throw Error(`Project[id=${t}, name=${e}] not found`);i=n[0]}else i=n;return i}async getProjectUrl({projectId:t,projectName:e}){if(void 0===t&&void 0===e)throw Error("Must provide either projectName or projectId");let a=await this.readProject({projectId:t,projectName:e}),i=await this._getTenantId();return`${this.getHostUrl()}/o/${i}/projects/p/${a.id}`}async getDatasetUrl({datasetId:t,datasetName:e}){if(void 0===t&&void 0===e)throw Error("Must provide either datasetName or datasetId");let a=await this.readDataset({datasetId:t,datasetName:e}),i=await this._getTenantId();return`${this.getHostUrl()}/o/${i}/datasets/${a.id}`}async _getTenantId(){if(null!==this._tenantId)return this._tenantId;let t=new URLSearchParams({limit:"1"});for await(let e of this._getPaginated("/sessions",t))return this._tenantId=e[0].tenant_id,e[0].tenant_id;throw Error("No projects found to resolve tenant.")}async *listProjects({projectIds:t,name:e,nameContains:a,referenceDatasetId:i,referenceDatasetName:s,includeStats:r,datasetVersion:n,referenceFree:o,metadata:l}={}){let h=new URLSearchParams;if(void 0!==t)for(let e of t)h.append("id",e);if(void 0!==e&&h.append("name",e),void 0!==a&&h.append("name_contains",a),void 0!==i)h.append("reference_dataset",i);else if(void 0!==s){let t=await this.readDataset({datasetName:s});h.append("reference_dataset",t.id)}for await(let t of(void 0!==r&&h.append("include_stats",r.toString()),void 0!==n&&h.append("dataset_version",n),void 0!==o&&h.append("reference_free",o.toString()),void 0!==l&&h.append("metadata",JSON.stringify(l)),this._getPaginated("/sessions",h)))yield*t}async deleteProject({projectId:t,projectName:e}){let a;if(void 0===t&&void 0===e)throw Error("Must provide projectName or projectId");if(void 0!==t&&void 0!==e)throw Error("Must provide either projectName or projectId, not both");a=void 0===t?(await this.readProject({projectName:e})).id:t,(0,d.AD)(a),await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/sessions/${a}`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(t,`delete session ${a} (${e})`,!0),t})}async uploadCsv({csvFile:t,fileName:e,inputKeys:a,outputKeys:i,description:s,dataType:r,name:n}){let o=`${this.apiUrl}/datasets/upload`,l=new FormData;l.append("file",t,e),a.forEach(t=>{l.append("input_keys",t)}),i.forEach(t=>{l.append("output_keys",t)}),s&&l.append("description",s),r&&l.append("data_type",r),n&&l.append("name",n);let h=await this.caller.call(async()=>{let t=await this._fetch(o,{method:"POST",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:l});return await (0,c.gJ)(t,"upload CSV"),t});return await h.json()}async createDataset(t,{description:e,dataType:a,inputsSchema:i,outputsSchema:s,metadata:r}={}){let n={name:t,description:e,extra:r?{metadata:r}:void 0};a&&(n.data_type=a),i&&(n.inputs_schema_definition=i),s&&(n.outputs_schema_definition=s);let o=JSON.stringify(n),l=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/datasets`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:o});return await (0,c.gJ)(t,"create dataset"),t});return await l.json()}async readDataset({datasetId:t,datasetName:e}){let a,i="/datasets",s=new URLSearchParams({limit:"1"});if(t&&e)throw Error("Must provide either datasetName or datasetId, not both");if(t)(0,d.AD)(t),i+=`/${t}`;else if(e)s.append("name",e);else throw Error("Must provide datasetName or datasetId");let r=await this._get(i,s);if(Array.isArray(r)){if(0===r.length)throw Error(`Dataset[id=${t}, name=${e}] not found`);a=r[0]}else a=r;return a}async hasDataset({datasetId:t,datasetName:e}){try{return await this.readDataset({datasetId:t,datasetName:e}),!0}catch(t){if(t instanceof Error&&t.message.toLocaleLowerCase().includes("not found"))return!1;throw t}}async diffDatasetVersions({datasetId:t,datasetName:e,fromVersion:a,toVersion:i}){let s=t;if(void 0===s&&void 0===e)throw Error("Must provide either datasetName or datasetId");if(void 0!==s&&void 0!==e)throw Error("Must provide either datasetName or datasetId, not both");void 0===s&&(s=(await this.readDataset({datasetName:e})).id);let r=new URLSearchParams({from_version:"string"==typeof a?a:a.toISOString(),to_version:"string"==typeof i?i:i.toISOString()});return await this._get(`/datasets/${s}/versions/diff`,r)}async readDatasetOpenaiFinetuning({datasetId:t,datasetName:e}){if(void 0!==t);else if(void 0!==e)t=(await this.readDataset({datasetName:e})).id;else throw Error("Must provide either datasetName or datasetId");let a=await this._getResponse(`/datasets/${t}/openai_ft`);return(await a.text()).trim().split("\n").map(t=>JSON.parse(t))}async *listDatasets({limit:t=100,offset:e=0,datasetIds:a,datasetName:i,datasetNameContains:s,metadata:r}={}){let n=new URLSearchParams({limit:t.toString(),offset:e.toString()});if(void 0!==a)for(let t of a)n.append("id",t);for await(let t of(void 0!==i&&n.append("name",i),void 0!==s&&n.append("name_contains",s),void 0!==r&&n.append("metadata",JSON.stringify(r)),this._getPaginated("/datasets",n)))yield*t}async updateDataset(t){let{datasetId:e,datasetName:a,...i}=t;if(!e&&!a)throw Error("Must provide either datasetName or datasetId");let s=e??(await this.readDataset({datasetName:a})).id;(0,d.AD)(s);let r=JSON.stringify(i),n=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/datasets/${s}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:r});return await (0,c.gJ)(t,"update dataset"),t});return await n.json()}async updateDatasetTag(t){let{datasetId:e,datasetName:a,asOf:i,tag:s}=t;if(!e&&!a)throw Error("Must provide either datasetName or datasetId");let r=e??(await this.readDataset({datasetName:a})).id;(0,d.AD)(r);let n=JSON.stringify({as_of:"string"==typeof i?i:i.toISOString(),tag:s});await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/datasets/${r}/tags`,{method:"PUT",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:n});return await (0,c.gJ)(t,"update dataset tags",!0),t})}async deleteDataset({datasetId:t,datasetName:e}){let a="/datasets",i=t;if(void 0!==t&&void 0!==e)throw Error("Must provide either datasetName or datasetId, not both");if(void 0!==e&&(i=(await this.readDataset({datasetName:e})).id),void 0!==i)(0,d.AD)(i),a+=`/${i}`;else throw Error("Must provide datasetName or datasetId");await this.caller.call(async()=>{let t=await this._fetch(this.apiUrl+a,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(t,`delete ${a}`,!0),t})}async indexDataset({datasetId:t,datasetName:e,tag:a}){let i=t;if(i||e)if(i&&e)throw Error("Must provide either datasetName or datasetId, not both");else i||(i=(await this.readDataset({datasetName:e})).id);else throw Error("Must provide either datasetName or datasetId");(0,d.AD)(i);let s=JSON.stringify({tag:a}),r=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/datasets/${i}/index`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:s});return await (0,c.gJ)(t,"index dataset"),t});await r.json()}async similarExamples(t,e,a,{filter:i}={}){let s={limit:a,inputs:t};void 0!==i&&(s.filter=i),(0,d.AD)(e);let r=JSON.stringify(s),n=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/datasets/${e}/search`,{headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,method:"POST",body:r});return await (0,c.gJ)(t,"fetch similar examples"),t});return(await n.json()).examples}async createExample(t,e,a){let s;if(U(t)&&(void 0!==e||void 0!==a))throw Error("Cannot provide outputs or options when using ExampleCreate object");let r=e?a?.datasetId:t.dataset_id,n=e?a?.datasetName:t.dataset_name;if(void 0===r&&void 0===n)throw Error("Must provide either datasetName or datasetId");if(void 0!==r&&void 0!==n)throw Error("Must provide either datasetName or datasetId, not both");void 0===r&&(r=(await this.readDataset({datasetName:n})).id);let o=(e?a?.createdAt:t.created_at)||new Date;s=U(t)?t:{inputs:t,outputs:e,created_at:o?.toISOString(),id:a?.exampleId,metadata:a?.metadata,split:a?.split,source_run_id:a?.sourceRunId,use_source_run_io:a?.useSourceRunIO,use_source_run_attachments:a?.useSourceRunAttachments,attachments:a?.attachments};let l=await this._uploadExamplesMultipart(r,[s]);return await this.readExample(l.example_ids?.[0]??i.A())}async createExamples(t){if(Array.isArray(t)){if(0===t.length)return[];let e=t[0].dataset_id,a=t[0].dataset_name;if(void 0===e&&void 0===a)throw Error("Must provide either datasetName or datasetId");if(void 0!==e&&void 0!==a)throw Error("Must provide either datasetName or datasetId, not both");void 0===e&&(e=(await this.readDataset({datasetName:a})).id);let i=await this._uploadExamplesMultipart(e,t);return await Promise.all(i.example_ids.map(t=>this.readExample(t)))}let{inputs:e,outputs:a,metadata:i,splits:s,sourceRunIds:r,useSourceRunIOs:n,useSourceRunAttachments:o,attachments:l,exampleIds:h,datasetId:d,datasetName:u}=t;if(void 0===e)throw Error("Must provide inputs when using legacy parameters");let p=d;if(void 0===p&&void 0===u)throw Error("Must provide either datasetName or datasetId");if(void 0!==p&&void 0!==u)throw Error("Must provide either datasetName or datasetId, not both");void 0===p&&(p=(await this.readDataset({datasetName:u})).id);let c=e.map((t,e)=>({dataset_id:p,inputs:t,outputs:a?.[e],metadata:i?.[e],split:s?.[e],id:h?.[e],attachments:l?.[e],source_run_id:r?.[e],use_source_run_io:n?.[e],use_source_run_attachments:o?.[e]})),m=await this._uploadExamplesMultipart(p,c);return await Promise.all(m.example_ids.map(t=>this.readExample(t)))}async createLLMExample(t,e,a){return this.createExample({input:t},{output:e},a)}async createChatExample(t,e,a){let i=t.map(t=>(0,o.$)(t)?(0,o.T)(t):t),s=(0,o.$)(e)?(0,o.T)(e):e;return this.createExample({input:i},{output:s},a)}async readExample(t){(0,d.AD)(t);let e=`/examples/${t}`,{attachment_urls:a,...i}=await this._get(e);return a&&(i.attachments=Object.entries(a).reduce((t,[e,a])=>(t[e.slice(11)]={presigned_url:a.presigned_url,mime_type:a.mime_type},t),{})),i}async *listExamples({datasetId:t,datasetName:e,exampleIds:a,asOf:i,splits:s,inlineS3Urls:r,metadata:n,limit:o,offset:l,filter:h,includeAttachments:d}={}){let u;if(void 0!==t&&void 0!==e)throw Error("Must provide either datasetName or datasetId, not both");if(void 0!==t)u=t;else if(void 0!==e)u=(await this.readDataset({datasetName:e})).id;else throw Error("Must provide a datasetName or datasetId");let p=new URLSearchParams({dataset:u}),c=i?"string"==typeof i?i:i?.toISOString():void 0;if(c&&p.append("as_of",c),p.append("inline_s3_urls",(r??!0).toString()),void 0!==a)for(let t of a)p.append("id",t);if(void 0!==s)for(let t of s)p.append("splits",t);if(void 0!==n){let t=JSON.stringify(n);p.append("metadata",t)}void 0!==o&&p.append("limit",o.toString()),void 0!==l&&p.append("offset",l.toString()),void 0!==h&&p.append("filter",h),!0===d&&["attachment_urls","outputs","metadata"].forEach(t=>p.append("select",t));let m=0;for await(let t of this._getPaginated("/examples",p)){for(let e of t){let{attachment_urls:t,...a}=e;t&&(a.attachments=Object.entries(t).reduce((t,[e,a])=>(t[e.slice(11)]={presigned_url:a.presigned_url,mime_type:a.mime_type||void 0},t),{})),yield a,m++}if(void 0!==o&&m>=o)break}}async deleteExample(t){(0,d.AD)(t);let e=`/examples/${t}`;await this.caller.call(async()=>{let t=await this._fetch(this.apiUrl+e,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(t,`delete ${e}`,!0),t})}async deleteExamples(t,e){if(t.forEach(t=>(0,d.AD)(t)),e?.hardDelete){let e=this._getPlatformEndpointPath("datasets/examples/delete");await this.caller.call(async()=>{let a=await this._fetch(`${this.apiUrl}${e}`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},body:JSON.stringify({example_ids:t,hard_delete:!0}),signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(a,"hard delete examples",!0),a})}else{let e=new URLSearchParams;t.forEach(t=>e.append("example_ids",t)),await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/examples?${e.toString()}`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(t,"delete examples",!0),t})}}async updateExample(t,e){let a,i,s;return a=e?t:t.id,(0,d.AD)(a),s=void 0!==(i=e?{id:a,...e}:t).dataset_id?i.dataset_id:(await this.readExample(a)).dataset_id,this._updateExamplesMultipart(s,[i])}async updateExamples(t){let e;return e=void 0===t[0].dataset_id?(await this.readExample(t[0].id)).dataset_id:t[0].dataset_id,this._updateExamplesMultipart(e,t)}async readDatasetVersion({datasetId:t,datasetName:e,asOf:a,tag:i}){let s;if(s=t||(await this.readDataset({datasetName:e})).id,(0,d.AD)(s),a&&i||!a&&!i)throw Error("Exactly one of asOf and tag must be specified.");let r=new URLSearchParams;void 0!==a&&r.append("as_of","string"==typeof a?a:a.toISOString()),void 0!==i&&r.append("tag",i);let n=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/datasets/${s}/version?${r.toString()}`,{method:"GET",headers:{...this.headers},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(t,"read dataset version"),t});return await n.json()}async listDatasetSplits({datasetId:t,datasetName:e,asOf:a}){let i;if(void 0===t&&void 0===e)throw Error("Must provide dataset name or ID");if(void 0!==t&&void 0!==e)throw Error("Must provide either datasetName or datasetId, not both");i=void 0===t?(await this.readDataset({datasetName:e})).id:t,(0,d.AD)(i);let s=new URLSearchParams,r=a?"string"==typeof a?a:a?.toISOString():void 0;return r&&s.append("as_of",r),await this._get(`/datasets/${i}/splits`,s)}async updateDatasetSplits({datasetId:t,datasetName:e,splitName:a,exampleIds:i,remove:s=!1}){let r;if(void 0===t&&void 0===e)throw Error("Must provide dataset name or ID");if(void 0!==t&&void 0!==e)throw Error("Must provide either datasetName or datasetId, not both");r=void 0===t?(await this.readDataset({datasetName:e})).id:t,(0,d.AD)(r);let n=JSON.stringify({split_name:a,examples:i.map(t=>((0,d.AD)(t),t)),remove:s});await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/datasets/${r}/splits`,{method:"PUT",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:n});return await (0,c.gJ)(t,"update dataset splits",!0),t})}async createFeedback(t,e,{score:a,value:s,correction:r,comment:n,sourceInfo:o,feedbackSourceType:l="api",sourceRunId:h,feedbackId:u,feedbackConfig:p,projectId:m,comparativeExperimentId:f}){if(!t&&!m)throw Error("One of runId or projectId must be provided");if(t&&m)throw Error("Only one of runId or projectId can be provided");let g={type:l??"api",metadata:o??{}};void 0===h||g?.metadata===void 0||g.metadata.__run||(g.metadata.__run={run_id:h}),g?.metadata!==void 0&&g.metadata.__run?.run_id!==void 0&&(0,d.AD)(g.metadata.__run.run_id);let w={id:u??i.A(),run_id:t,key:e,score:S(a),value:s,correction:r,comment:n,feedback_source:g,comparative_experiment_id:f,feedbackConfig:p,session_id:m},_=JSON.stringify(w),y=`${this.apiUrl}/feedback`;return await this.caller.call(async()=>{let t=await this._fetch(y,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:_});return await (0,c.gJ)(t,"create feedback",!0),t}),w}async updateFeedback(t,{score:e,value:a,correction:i,comment:s}){let r={};null!=e&&(r.score=S(e)),null!=a&&(r.value=a),null!=i&&(r.correction=i),null!=s&&(r.comment=s),(0,d.AD)(t);let n=JSON.stringify(r);await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/feedback/${t}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:n});return await (0,c.gJ)(e,"update feedback",!0),e})}async readFeedback(t){(0,d.AD)(t);let e=`/feedback/${t}`;return await this._get(e)}async deleteFeedback(t){(0,d.AD)(t);let e=`/feedback/${t}`;await this.caller.call(async()=>{let t=await this._fetch(this.apiUrl+e,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(t,`delete ${e}`,!0),t})}async *listFeedback({runIds:t,feedbackKeys:e,feedbackSourceTypes:a}={}){let i=new URLSearchParams;if(t)for(let e of t)(0,d.AD)(e),i.append("run",e);if(e)for(let t of e)i.append("key",t);if(a)for(let t of a)i.append("source",t);for await(let t of this._getPaginated("/feedback",i))yield*t}async createPresignedFeedbackToken(t,e,{expiration:a,feedbackConfig:i}={}){let s={run_id:t,feedback_key:e,feedback_config:i};a?"string"==typeof a?s.expires_at=a:(a?.hours||a?.minutes||a?.days)&&(s.expires_in=a):s.expires_in={hours:3};let r=JSON.stringify(s),n=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/feedback/tokens`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:r});return await (0,c.gJ)(t,"create presigned feedback token"),t});return await n.json()}async createComparativeExperiment({name:t,experimentIds:e,referenceDatasetId:a,createdAt:i,description:s,metadata:r,id:n}){if(0===e.length)throw Error("At least one experiment is required");if(a||(a=(await this.readProject({projectId:e[0]})).reference_dataset_id),null==!a)throw Error("A reference dataset is required");let o={id:n,name:t,experiment_ids:e,reference_dataset_id:a,description:s,created_at:(i??new Date)?.toISOString(),extra:{}};r&&(o.extra.metadata=r);let l=JSON.stringify(o);return(await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/datasets/comparative`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:l});return await (0,c.gJ)(t,"create comparative experiment"),t})).json()}async *listPresignedFeedbackTokens(t){(0,d.AD)(t);let e=new URLSearchParams({run_id:t});for await(let t of this._getPaginated("/feedback/tokens",e))yield*t}_selectEvalResults(t){let e;return"results"in t?t.results:Array.isArray(t)?t:[t]}async _logEvaluationFeedback(t,e,a){let i=this._selectEvalResults(t),s=[];for(let t of i){let i=a||{};t.evaluatorInfo&&(i={...t.evaluatorInfo,...i});let r=null;t.targetRunId?r=t.targetRunId:e&&(r=e.id),s.push(await this.createFeedback(r,t.key,{score:t.score,value:t.value,comment:t.comment,correction:t.correction,sourceInfo:i,sourceRunId:t.sourceRunId,feedbackConfig:t.feedbackConfig,feedbackSourceType:"model"}))}return[i,s]}async logEvaluationFeedback(t,e,a){let[i]=await this._logEvaluationFeedback(t,e,a);return i}async *listAnnotationQueues(t={}){let{queueIds:e,name:a,nameContains:i,limit:s}=t,r=new URLSearchParams;e&&e.forEach((t,e)=>{(0,d.AD)(t,`queueIds[${e}]`),r.append("ids",t)}),a&&r.append("name",a),i&&r.append("name_contains",i),r.append("limit",(void 0!==s?Math.min(s,100):100).toString());let n=0;for await(let t of this._getPaginated("/annotation-queues",r))if(yield*t,n++,void 0!==s&&n>=s)break}async createAnnotationQueue(t){let{name:e,description:a,queueId:s,rubricInstructions:r}=t,n=JSON.stringify(Object.fromEntries(Object.entries({name:e,description:a,id:s||i.A(),rubric_instructions:r}).filter(([t,e])=>void 0!==e)));return(await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/annotation-queues`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:n});return await (0,c.gJ)(t,"create annotation queue"),t})).json()}async readAnnotationQueue(t){return(await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/annotation-queues/${(0,d.AD)(t,"queueId")}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"read annotation queue"),e})).json()}async updateAnnotationQueue(t,e){let{name:a,description:i,rubricInstructions:s}=e,r=JSON.stringify({name:a,description:i,rubric_instructions:s});await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/annotation-queues/${(0,d.AD)(t,"queueId")}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:r});return await (0,c.gJ)(e,"update annotation queue",!0),e})}async deleteAnnotationQueue(t){await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/annotation-queues/${(0,d.AD)(t,"queueId")}`,{method:"DELETE",headers:{...this.headers,Accept:"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"delete annotation queue",!0),e})}async addRunsToAnnotationQueue(t,e){let a=JSON.stringify(e.map((t,e)=>(0,d.AD)(t,`runIds[${e}]`).toString()));await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/annotation-queues/${(0,d.AD)(t,"queueId")}/runs`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:a});return await (0,c.gJ)(e,"add runs to annotation queue",!0),e})}async getRunFromAnnotationQueue(t,e){let a=`/annotation-queues/${(0,d.AD)(t,"queueId")}/run`;return(await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}${a}/${e}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(t,"get run from annotation queue"),t})).json()}async deleteRunFromAnnotationQueue(t,e){await this.caller.call(async()=>{let a=await this._fetch(`${this.apiUrl}/annotation-queues/${(0,d.AD)(t,"queueId")}/runs/${(0,d.AD)(e,"queueRunId")}`,{method:"DELETE",headers:{...this.headers,Accept:"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(a,"delete run from annotation queue",!0),a})}async getSizeFromAnnotationQueue(t){return(await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/annotation-queues/${(0,d.AD)(t,"queueId")}/size`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"get size from annotation queue"),e})).json()}async _currentTenantIsOwner(t){let e=await this._getSettings();return"-"==t||e.tenant_handle===t}async _ownerConflictError(t,e){let a=await this._getSettings();return Error(`Cannot ${t} for another tenant.

      Current tenant: ${a.tenant_handle}

      Requested tenant: ${e}`)}async _getLatestCommitHash(t){let e=await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}/commits/${t}/?limit=1&offset=0`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(e,"get latest commit hash"),e}),a=await e.json();if(0!==a.commits.length)return a.commits[0].commit_hash}async _likeOrUnlikePrompt(t,e){let[a,i,s]=(0,p.l)(t),r=JSON.stringify({like:e});return(await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/likes/${a}/${i}`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:r});return await (0,c.gJ)(t,`${e?"like":"unlike"} prompt`),t})).json()}async _getPromptUrl(t){let[e,a,i]=(0,p.l)(t);if(await this._currentTenantIsOwner(e)){let t=await this._getSettings();return"latest"!==i?`${this.getHostUrl()}/prompts/${a}/${i.substring(0,8)}?organizationId=${t.id}`:`${this.getHostUrl()}/prompts/${a}?organizationId=${t.id}`}return"latest"!==i?`${this.getHostUrl()}/hub/${e}/${a}/${i.substring(0,8)}`:`${this.getHostUrl()}/hub/${e}/${a}`}async promptExists(t){return!!await this.getPrompt(t)}async likePrompt(t){return this._likeOrUnlikePrompt(t,!0)}async unlikePrompt(t){return this._likeOrUnlikePrompt(t,!1)}async *listCommits(t){for await(let e of this._getPaginated(`/commits/${t}/`,new URLSearchParams,t=>t.commits))yield*e}async *listPrompts(t){let e=new URLSearchParams;for await(let a of(e.append("sort_field",t?.sortField??"updated_at"),e.append("sort_direction","desc"),e.append("is_archived",(!!t?.isArchived).toString()),t?.isPublic!==void 0&&e.append("is_public",t.isPublic.toString()),t?.query&&e.append("query",t.query),this._getPaginated("/repos",e,t=>t.repos)))yield*a}async getPrompt(t){let[e,a,i]=(0,p.l)(t),s=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/repos/${e}/${a}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return t?.status===404?null:(await (0,c.gJ)(t,"get prompt"),t)}),r=await s?.json();return r?.repo?r.repo:null}async createPrompt(t,e){let a=await this._getSettings();if(e?.isPublic&&!a.tenant_handle)throw Error(`Cannot create a public prompt without first

        creating a LangChain Hub handle.
        You can add a handle by creating a public prompt at:

        https://smith.langchain.com/prompts`);let[i,s,r]=(0,p.l)(t);if(!await this._currentTenantIsOwner(i))throw await this._ownerConflictError("create a prompt",i);let n=JSON.stringify({repo_handle:s,...e?.description&&{description:e.description},...e?.readme&&{readme:e.readme},...e?.tags&&{tags:e.tags},is_public:!!e?.isPublic}),o=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/repos/`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:n});return await (0,c.gJ)(t,"create prompt"),t}),{repo:l}=await o.json();return l}async createCommit(t,e,a){if(!await this.promptExists(t))throw Error("Prompt does not exist, you must create it first.");let[i,s,r]=(0,p.l)(t),n=a?.parentCommitHash!=="latest"&&a?.parentCommitHash?a?.parentCommitHash:await this._getLatestCommitHash(`${i}/${s}`),o=JSON.stringify({manifest:JSON.parse(JSON.stringify(e)),parent_commit:n}),l=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/commits/${i}/${s}`,{method:"POST",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:o});return await (0,c.gJ)(t,"create commit"),t}),h=await l.json();return this._getPromptUrl(`${i}/${s}${h.commit_hash?`:${h.commit_hash}`:""}`)}async updateExamplesMultipart(t,e=[]){return this._updateExamplesMultipart(t,e)}async _updateExamplesMultipart(t,e=[]){if(!await this._getDatasetExamplesMultiPartSupport())throw Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");let a=new FormData;for(let t of e){let e=t.id,i={...t.metadata&&{metadata:t.metadata},...t.split&&{split:t.split}},s=new Blob([(0,f.l)(i,`Serializing body for example with id: ${e}`)],{type:"application/json"});if(a.append(e,s),t.inputs){let i=new Blob([(0,f.l)(t.inputs,`Serializing inputs for example with id: ${e}`)],{type:"application/json"});a.append(`${e}.inputs`,i)}if(t.outputs){let i=new Blob([(0,f.l)(t.outputs,`Serializing outputs whle updating example with id: ${e}`)],{type:"application/json"});a.append(`${e}.outputs`,i)}if(t.attachments)for(let[i,s]of Object.entries(t.attachments)){let t,r;Array.isArray(s)?[t,r]=s:(t=s.mimeType,r=s.data);let n=new Blob([r],{type:`${t}; length=${r.byteLength}`});a.append(`${e}.attachment.${i}`,n)}if(t.attachments_operations){let i=new Blob([(0,f.l)(t.attachments_operations,`Serializing attachments while updating example with id: ${e}`)],{type:"application/json"});a.append(`${e}.attachments_operations`,i)}}let i=t??e[0]?.dataset_id;return(await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${i}/examples`)}`,{method:"PATCH",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:a});return await (0,c.gJ)(t,"update examples"),t})).json()}async uploadExamplesMultipart(t,e=[]){return this._uploadExamplesMultipart(t,e)}async _uploadExamplesMultipart(t,e=[]){if(!await this._getDatasetExamplesMultiPartSupport())throw Error("Your LangSmith deployment does not allow using the multipart examples endpoint, please upgrade your deployment to the latest version.");let a=new FormData;for(let t of e){let e=(t.id??i.A()).toString(),s={created_at:t.created_at,...t.metadata&&{metadata:t.metadata},...t.split&&{split:t.split},...t.source_run_id&&{source_run_id:t.source_run_id},...t.use_source_run_io&&{use_source_run_io:t.use_source_run_io},...t.use_source_run_attachments&&{use_source_run_attachments:t.use_source_run_attachments}},r=new Blob([(0,f.l)(s,`Serializing body for uploaded example with id: ${e}`)],{type:"application/json"});if(a.append(e,r),t.inputs){let i=new Blob([(0,f.l)(t.inputs,`Serializing inputs for uploaded example with id: ${e}`)],{type:"application/json"});a.append(`${e}.inputs`,i)}if(t.outputs){let i=new Blob([(0,f.l)(t.outputs,`Serializing outputs for uploaded example with id: ${e}`)],{type:"application/json"});a.append(`${e}.outputs`,i)}if(t.attachments)for(let[i,s]of Object.entries(t.attachments)){let t,r;Array.isArray(s)?[t,r]=s:(t=s.mimeType,r=s.data);let n=new Blob([r],{type:`${t}; length=${r.byteLength}`});a.append(`${e}.attachment.${i}`,n)}}return(await this.caller.call(async()=>{let e=await this._fetch(`${this.apiUrl}${this._getPlatformEndpointPath(`datasets/${t}/examples`)}`,{method:"POST",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:a});return await (0,c.gJ)(e,"upload examples"),e})).json()}async updatePrompt(t,e){if(!await this.promptExists(t))throw Error("Prompt does not exist, you must create it first.");let[a,i]=(0,p.l)(t);if(!await this._currentTenantIsOwner(a))throw await this._ownerConflictError("update a prompt",a);let s={};if(e?.description!==void 0&&(s.description=e.description),e?.readme!==void 0&&(s.readme=e.readme),e?.tags!==void 0&&(s.tags=e.tags),e?.isPublic!==void 0&&(s.is_public=e.isPublic),e?.isArchived!==void 0&&(s.is_archived=e.isArchived),0===Object.keys(s).length)throw Error("No valid update options provided");let r=JSON.stringify(s);return(await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/repos/${a}/${i}`,{method:"PATCH",headers:{...this.headers,"Content-Type":"application/json"},signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions,body:r});return await (0,c.gJ)(t,"update prompt"),t})).json()}async deletePrompt(t){if(!await this.promptExists(t))throw Error("Prompt does not exist, you must create it first.");let[e,a,i]=(0,p.l)(t);if(!await this._currentTenantIsOwner(e))throw await this._ownerConflictError("delete a prompt",e);return(await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/repos/${e}/${a}`,{method:"DELETE",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(t,"delete prompt"),t})).json()}async pullPromptCommit(t,e){let[a,i,s]=(0,p.l)(t),r=await this.caller.call(async()=>{let t=await this._fetch(`${this.apiUrl}/commits/${a}/${i}/${s}${e?.includeModel?"?include_model=true":""}`,{method:"GET",headers:this.headers,signal:AbortSignal.timeout(this.timeout_ms),...this.fetchOptions});return await (0,c.gJ)(t,"pull prompt commit"),t}),n=await r.json();return{owner:a,repo:i,commit_hash:n.commit_hash,manifest:n.manifest,examples:n.examples}}async _pullPrompt(t,e){return JSON.stringify((await this.pullPromptCommit(t,{includeModel:e?.includeModel})).manifest)}async pushPrompt(t,e){return(await this.promptExists(t)?e&&Object.keys(e).some(t=>"object"!==t)&&await this.updatePrompt(t,{description:e?.description,readme:e?.readme,tags:e?.tags,isPublic:e?.isPublic}):await this.createPrompt(t,{description:e?.description,readme:e?.readme,tags:e?.tags,isPublic:e?.isPublic}),e?.object)?await this.createCommit(t,e?.object,{parentCommitHash:e?.parentCommitHash}):await this._getPromptUrl(t)}async clonePublicDataset(t,e={}){let{sourceApiUrl:a=this.apiUrl,datasetName:i}=e,[s,r]=this.parseTokenOrUrl(t,a),n=new E({apiUrl:s,apiKey:"placeholder"}),o=await n.readSharedDataset(r),l=i||o.name;try{if(await this.hasDataset({datasetId:l}))return void console.log(`Dataset ${l} already exists in your tenant. Skipping.`)}catch(t){}let h=await n.listSharedExamples(r),d=await this.createDataset(l,{description:o.description,dataType:o.data_type||"kv",inputsSchema:o.inputs_schema_definition??void 0,outputsSchema:o.outputs_schema_definition??void 0});try{await this.createExamples({inputs:h.map(t=>t.inputs),outputs:h.flatMap(t=>t.outputs?[t.outputs]:[]),datasetId:d.id})}catch(t){throw console.error(`An error occurred while creating dataset ${l}. You should delete it manually.`),t}}parseTokenOrUrl(t,e,a=2,i="dataset"){try{return(0,d.AD)(t),[e,t]}catch(t){}try{let s=new URL(t).pathname.split("/").filter(t=>""!==t);if(s.length>=a){let t=s[s.length-a];return[e,t]}throw Error(`Invalid public ${i} URL: ${t}`)}catch(e){throw Error(`Invalid public ${i} URL or token: ${t}`)}}async awaitPendingTraceBatches(){if(this.manualFlushMode)return console.warn("[WARNING]: When tracing in manual flush mode, you must call `await client.flush()` manually to submit trace batches."),Promise.resolve();await new Promise(t=>setTimeout(t,1)),await Promise.all([...this.autoBatchQueue.items.map(({itemPromise:t})=>t),this.batchIngestCaller.queue.onIdle()]),void 0!==this.langSmithToOTELTranslator&&await (0,r.aF)()?.DEFAULT_LANGSMITH_SPAN_PROCESSOR?.forceFlush()}}function U(t){return"dataset_id"in t||"dataset_name"in t}}}]);